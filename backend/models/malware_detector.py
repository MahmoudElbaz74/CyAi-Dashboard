import logging
import os
import tempfile
from typing import Dict, Any, Optional, List
import hashlib
from datetime import datetime

import torch
import torch.nn as nn
import torch.nn.functional as F
from torchvision import transforms
from PIL import Image
from pydantic import BaseModel

logger = logging.getLogger(__name__)

# ---- من الكود اللي بعته (config و LoadImage و transform) ----

config = {
    "image_shape": (224, 224),
    "model": {"num_classes": 22, "in_channels": 1},
    "device": "cuda" if torch.cuda.is_available() else "cpu",
    "checkpoint_path": "/content/drive/MyDrive/NTI_Project/model/xception-epoch=00-val_f1=0.91.ckpt",
    "classes_names": [
        'AgentTesla', 'Amadey', 'AsyncRAT', 'AveMariaRAT', 'Benign',
        'CobaltStrike', 'Formbook', 'GCleaner', 'GandCrab', 'Gozi', 'GuLoader',
        'Heodo', 'IcedID', 'Loki', 'LummaStealer', 'Mirai', 'NanoCore',
        'Prometei', 'RedLineStealer', 'RemcosRAT', 'SilentBuilder',
        'SmokeLoader'
    ]
}

class LoadImage:
    def __call__(self, malware_path: str) -> Image.Image:
        with open(malware_path, "rb") as f:
            data = f.read()
        import numpy as np

        arr = np.frombuffer(data, dtype=np.uint8)
        length = arr.size
        needed = (1024 * 1024) - length
        if needed > 0:
            arr = np.concatenate([arr, np.zeros(needed, dtype=np.uint8)])
        elif needed < 0:
            arr = arr[: (1024 * 1024)]
        img = arr.reshape((1024, 1024))
        # من التعديلات: كونها صورة RGB بدل "L"
        img = Image.fromarray(img, mode="L").convert("RGB")
        return img

test_transform = transforms.Compose([
    LoadImage(),
    transforms.Resize(config["image_shape"], antialias=True),
    transforms.ToTensor()
    # لو تحب تضيف Normalize ممكن تضيف هنا
])

# ---- موديل Xception وتحميله ----

def load_xception_model():
    import timm

    device = config["device"]
    model = timm.create_model('xception', pretrained=False)

    # عدّل conv1 ليقبل قناة واحدة
    original_conv1 = model.conv1
    model.conv1 = nn.Conv2d(
        in_channels=config["model"]["in_channels"],
        out_channels=original_conv1.out_channels,
        kernel_size=original_conv1.kernel_size,
        stride=original_conv1.stride,
        padding=original_conv1.padding,
        bias=False
    )
    with torch.no_grad():
        # استخدم المتوسط لأوزان RGB
        model.conv1.weight = nn.Parameter(
            original_conv1.weight.mean(dim=1, keepdim=True)
        )

    # عدّل طبقة التصنيف
    num_ftrs = model.fc.in_features
    model.fc = nn.Linear(num_ftrs, config["model"]["num_classes"])

    # حمّل checkpoint
    checkpoint = torch.load(config["checkpoint_path"], map_location=device)
    state = checkpoint.get('state_dict', checkpoint)
    new_state = {}
    for k, v in state.items():
        if k.startswith('engine.'):
            new_state[k[7:]] = v
        else:
            new_state[k] = v
    model.load_state_dict(new_state, strict=False)
    model.to(device)
    model.eval()
    logger.info("Xception model loaded to device %s", device)
    return model

def predict_malware(file_path: str, model) -> (str, float):
    if model is None:
        return "Unknown", 0.0
    try:
        device = config["device"]
        img = LoadImage()(file_path)
        tensor = test_transform(img)  # لكن هنا test_transform يبدأ بـ LoadImage → خطأ: يجب تعديل
        # Actually test_transform expects path, لكن LoadImage returns image, فسنعدل:
        # الأفضل: ننفذ LoadImage ثم transform بدون تحويله مرتين

        # تعديل: نفصل التنقيح
        img = LoadImage()(file_path)
        tensor = transforms.Resize(config["image_shape"], antialias=True)(img)
        tensor = transforms.ToTensor()(tensor)
        tensor = tensor.unsqueeze(0).to(device)

        with torch.no_grad():
            outputs = model(tensor)
            probs = F.softmax(outputs, dim=1)
            top_prob, idx = torch.max(probs, dim=1)
            prob = top_prob.item()
            idx0 = idx.item()
            label = config["classes_names"][idx0]
            return label, prob * 100.0
    except Exception as e:
        logger.error("Error in predict_malware: %s", e)
        return "Unknown", 0.0

# ---- الأصناف BaseModel ----

class MalwareDetectionRequest(BaseModel):
    file_path: Optional[str] = None
    file_content: Optional[bytes] = None
    file_name: Optional[str] = None
    scan_type: Optional[str] = "quick"
    include_family_detection: Optional[bool] = True

class MalwareDetectionResponse(BaseModel):
    is_malicious: bool
    confidence: float
    threat_level: str
    malware_family: Optional[str]
    malware_type: Optional[str]
    file_info: Dict[str, Any]
    analysis_details: Dict[str, Any]
    recommendations: List[str]

# ---- كلاس MalwareDetector المعدّل ----

class MalwareDetector:
    def __init__(self, model_path: Optional[str] = None):
        self.xception_model = None
        self.threat_levels = ["Low", "Medium", "High", "Critical"]
        self.malware_families = [
            "Trojan", "Virus", "Worm", "Ransomware", "Spyware",
            "Adware", "Rootkit", "Backdoor", "Botnet", "Keylogger"
        ]
        self.malware_types = [
            "Executable", "Script", "Document", "Archive", "Network"
        ]
        # نحمل الموديل فعليًا
        try:
            self.xception_model = load_xception_model()
        except Exception as e:
            logger.error("Failed loading model in MalwareDetector init: %s", e)
            self.xception_model = None

    def analyze_file(self, request: MalwareDetectionRequest) -> MalwareDetectionResponse:
        file_info = self._get_file_info(request)
        if self.xception_model is not None:
            label, confidence = predict_malware(file_info.get("file_path", ""), self.xception_model)
        else:
            # لو الموديل فشل، استخدم fallback قديم أو اعتبرها benign
            label, confidence = "Benign", 0.0

        is_malicious = (label != "Benign")
        # threat level بناءً على الثقة
        if confidence > 80:
            threat = "High"
        elif confidence > 50:
            threat = "Medium"
        else:
            threat = "Low"

        details = {
            "model_prediction": label,
            "model_confidence": confidence
        }

        family = None
        mtype = None
        if is_malicious and request.include_family_detection:
            # مثال سريع لكشف العائلة بناءً على الاسم
            fname = file_info.get("file_name", "").lower()
            if "trojan" in fname or "backdoor" in fname:
                family = "Trojan"
            elif "ransom" in fname:
                family = "Ransomware"
            else:
                family = "Unknown"
            # نوع الموديل حسب الامتداد
            ext = file_info.get("file_extension", "")
            if ext in [".exe", ".dll", ".sys"]:
                mtype = "Executable"
            else:
                mtype = "Unknown"

        recommendations = ["No action needed"] if not is_malicious else ["Quarantine file", "Further analysis"]

        return MalwareDetectionResponse(
            is_malicious=is_malicious,
            confidence=confidence,
            threat_level=threat,
            malware_family=family,
            malware_type=mtype,
            file_info=file_info,
            analysis_details=details,
            recommendations=recommendations
        )

    def _get_file_info(self, request: MalwareDetectionRequest) -> Dict[str, Any]:
        info = {
            "timestamp": datetime.now().isoformat(),
            "scan_type": request.scan_type
        }
        if request.file_path and os.path.exists(request.file_path):
            info.update({
                "file_path": request.file_path,
                "file_name": os.path.basename(request.file_path),
                "file_size": os.path.getsize(request.file_path),
                "file_extension": os.path.splitext(request.file_path)[1].lower(),
                "file_hash": self._calculate_file_hash(request.file_path)
            })
        elif request.file_content:
            info.update({
                "file_name": request.file_name or "unknown",
                "file_size": len(request.file_content),
                "file_extension": None,
                "file_hash": hashlib.sha256(request.file_content).hexdigest()
            })
        else:
            raise ValueError("No file path or content")
        return info

    def _calculate_file_hash(self, path: str) -> str:
        h = hashlib.sha256()
        with open(path, "rb") as f:
            for chunk in iter(lambda: f.read(4096), b""):
                h.update(chunk)
        return h.hexdigest()

    def scan_batch(self, requests: List[MalwareDetectionRequest]) -> List[MalwareDetectionResponse]:
        results = []
        for req in requests:
            try:
                res = self.analyze_file(req)
                results.append(res)
            except Exception as e:
                logger.error("Error in batch analyze: %s", e)
                # إضافة نتيجة فاشلة
                results.append(MalwareDetectionResponse(
                    is_malicious=False,
                    confidence=0.0,
                    threat_level="Low",
                    malware_family=None,
                    malware_type=None,
                    file_info={"error": str(e)},
                    analysis_details={"error": str(e)},
                    recommendations=["Analysis failed"]
                ))
        return results

    def get_model_info(self) -> Dict[str, Any]:
        return {
            "model_name": "XceptionClassifier",
            "num_classes": config["model"]["num_classes"],
            "loaded": self.xception_model is not None
        }
